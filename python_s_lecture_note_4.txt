리스트 

장점: "다른 형식"의 데이터들을 하나의 리스트 구조로 만들 수 있음.(서로 다른 데이터형도 하나로 묶을 수 있음)

형식 : 리스트명 = [값1,값2,값3...]
	리스트명[0] = 값1...

추가 : append추가시 뒤로 차례대로 들어감.

-1은 항상 리스트의 마지막원소! 두바튀돌지는 않음..! 원소4개인 리스트에 -4는 존재하지만 -5는 존재하지 않음
리스트범위지정 = 리스트명[a:b] ==>b포함하지 않음.
리스트명[:a]  =>처음부터 a-1까지!

리스트끼리 더할 수 있음 ==>바로 오른쪽 끝에 붙어서 연결됨

건너뛰며 추출
리스트명[::2] ==>2씩 건너뛰면서
리스트명[::-2] ==>2씩 끝에서부터 건너뛰면서 거꾸로

리스트값 변경
aa=[1,2,3]
aa[0] = 200
aa = [200,2,3]

aa=1,2,3]
aa[1:2]=[200,201]  #2의 자리에 두개의 숫자를 넣을 수 있음 
aa=[1,200,201,3] #자동으로 밀림! 매우 편함!

aa=[1,2,3]
aa[1] = [6,6] #이렇게 범위를 주지 않고 썼을 때는...
aa=[1,[6,6],3] #리스트 자체가 들어가고 aa의 index = 1은 리스트 그 자체가 됨


리스트 삭제
aa=[1,2,3]
del(aa[1])
aa=[1,3]

리스트 없애서 초기화하기

aa=[1,2,3,4]
aa[1:4]=[] #리스트 삭제해버림
aa=[1,4]


pop() : 데이터하나를 꺼내옴. 데이터의 가장 마지막꺼가~(리스트에서 해당 항목이 삭제됨)        리스트명.pop()
sort() : 현재 내가 가지고 있는 리스트의 항목을 정렬한다.          리스트명.sort()
index() : 지정한 값을 찾아 해당 위치를 반환한다.		리스트명.index(찾을값)
sorted() : sotred(딕셔너리이름.items(), key = operator.itemgetter(1), reverse = -1)
del() : 리스트에서 해당 위치의 항목을 삭제한다.			del.리스트명(위치)
	#del 과 remove의 차이
	del a[인덱스] # 리스트 a의 해당 인덱스 원소가 삭제됩니다!
	a.remove(원소) # 리스트 a의 해당 원소가 삭제됩니다! ->자리가 남아있지 않음
len(): 리스트의 길이 반환
count() : 찾는 원소의 개수 반환			 리스트명.count(원하는 원소)
.
.
.
.
엄청 많아서 찾아서 쓰면 좋음!



튜플 : ()소괄호로 생성, ()생략 가능, "읽기만" 가능한 "읽기전용"자료, readonly
tt=(10,20,30)

tt3 = (10)
tt3= 10; ==>튜플 데이터가 하나일때는 반드시 세미콜론을 써서 변수선언과 구분해줌!

@ 항목접근과 범위접은은 리스트와 동일
@@ 튜플 덧셈과 곱셈 가능
	곱셈 ==> 튜플 내용을 반복함.


튜플 ====== 리스트로 바꿨다가 다시 튜플로 바꿀 수 있음

ex)mytuple = (1,2,3)
리스트로 바꾸기 mylist = list(mytuple)
추가하기 mylist.append(4)
다시 튜플로 바꿔주기 mytuple = tuple(mylist)



튜플의 장점!!
packing & unpacking

packing : 여러 타입의 데이터가 하나의 튜플로 포장된 것
unpacking :튜플을 항목별로 각각 풀어서 변수에 저장하는 것

ex) card = 'red', 4, 6, 'apple' 튜플생성 (패킹)
a, b, c, d = card 튜플 항목 개별 할당(언패킹)


딕셔너리 개념
:쌍 2개가 하나도 묶인 자료구조

형태 : 딕셔너리변수 = {키:값, 키:값...}
출력하면 {}에 쌓여서 출력됨

키 추가하는 법

딕셔너리명['키'] = '값'
=>추가되어 저장됨

딕셔너리명['존재하는 키'] = '다른 값'
=>수정되어 저장됨

del(딕셔너리명['키']) 로 삭제함.

딕셔너리명 = {'키1':값1, '키2':값2,'키1':값1;'}==>마지막 키1값이 앞의 키1대신 반영됨.

딕셔너리명['키']를통해 값을 구할 수 있음 or 딕셔너리명.get('키')
차이점: 전자는 키가 없을때 오류가 나지만 후자는 키가 없을때 아무것도 반환하지 않고 오류를 내보내지 않음


딕셔너리명.keys():모든 키 반환 dic_values([키값들]) -> default
이게 싫으면
list(딕셔너리명.keys())
or tuple(딕셔너리명.keys())

딕셔너리명.values() : 모든 값을 리스트로 만들어 반환 dic_values([값들]) -> default
이게 싫으면
list(딕셔너리명.values())
or tuple(딕셔너리명.values())

.items() : 튜플형태로 구할 수 있음


'키값' in 딕셔너리명 =>존재하면 True반환, 없으면 False반환

itemgetter 는 operator안에 있기 때문에 operator반드시 import해줘야함.